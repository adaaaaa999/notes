#上課內容包含:
#range、雙層for in迴圈
#例外處理
#亂數
#群集資料set、切片
#while無窮迴圈

#============================================================================================        
#RANGE=========================================================================================
#============================================================================================
a = range(18) # 產生0~17連續數字
a = range(50, 55) # 產生50~54連續數字
a = range(0, 10, 2) # 產生0 2 4 6 8
a = range(5, 16, 5)
a = range(5, 0, -1) #包含起點、不包含終點
a = list(a)
print(a)

#輸出星號10個
for i in range(10):#i執行10次
    print('*', end='')#印出*號，結尾不換行

#輸入數字形成正方形(雙for in迴圈)
#迴圈不要寫太多層，最多寫3層就好，2層是基本
user = int( input('請輸入一個數字: ') )
for j in range(user):#ex:執行3次下面的迴圈，所以會有三行3*號
    for i in range(user):#ex:執行3次列印*號，不換行，所以每行會出現3個*號
        print('*', end='')#原本預設end是換行，因此我們在後面修改end，讓他不會換行
    print()#外圈

#九九乘法表
for k in range (1,10):
    for i in range(1,10):
        b=k*i
        print(f'{k} x {i} = {b} ')
    print('\n')

#============================================================================================        
#亂數=========================================================================================
#============================================================================================
import random
a = random.randint(1,10) #產生1~10之間的隨機整數
def p (msg):
    print(msg)
#寫這樣的好處是，如果今天抽到3，則可以省下3之後的程式效能，同時能夠寫else
#如果都是寫if就會需要較多的效能去判斷
if a==1:
    p('今天會發獎金')
elif a==2:
    p('今天會撿到錢')
elif a==3:
    p('今天會中發票')
elif a==4:
    p('今天我買的股票都漲停')
elif a==5:
    p('今天會撿到便宜')
else:
    p('今天沒事')

#猜拳遊戲
import random
for i in range(100):
 try:
    user = int(input('請問是否要玩猜拳，要的話請輸入1，不要請輸入2: '))
    if user == 2:
        print('歡迎下次再玩')
        break
    elif user ==1:
        print('0為剪刀，1為石頭，2為布')
        pc = random.randint(0,2) #0剪刀 1石頭 2布
#random.randint需要給範圍
        user = int(input('請出拳:'))
        if user<0 or user>2:
            print('你是不是按錯了:) 請重新選擇是否要玩遊戲')
            continue
        print(f'電腦出拳 :{['剪刀','石頭','布'][pc]}')
        if pc == user:
            print('平手')
        elif pc==0 and user==1:
            print('你贏了')
        elif pc==0 and user==2:
            print('你輸了')
        elif pc==1 and user==0:
            print('你輸了')
        elif pc==1 and user==2:
            print('你贏了')
        elif pc==2 and user==0:
            print('你贏了')
        elif pc==2 and user==1:
            print('你輸了')
 except ValueError:
     print('不可輸入非數字，請重新選擇')

#============================================================================================        
#切片=========================================================================================
#============================================================================================
a = [12, 32, 55, 64, 73, 89, 24, 0]
print(a[1:6])#從32(序號1)取到89(序號5)，不含終點 => [32,55,64,73,89]
print(a[1:6:3])#從1隔三個取資料，不含終點 => [32,73]
print(a[-5:-1])#開頭是負數，則順序要顛倒，意即0為序號-1，64為序號-5。且因為step為負，負負得正因此向後取
print(a[::-1])#資料會顛倒
print(a[::])#默認都是1
print(a[3:-1:3])
print(a[-1:-6:-1])
print(a[1:6:-1]) #拿不到資料，要注意方向
print(a[::len(a)-1]) #拿第一筆跟最後一筆資料

a = [12,32,55,64,73,89,24,0]
print (a[1:6:-1]) #step為負，則拿資料的方向會是反方向(最開頭從-1開始計算)
#step為正，拿資料的方向會是正方向(最開頭從0開始計算)
print (a[-1:-5:-2]) #不含終點
print (a[0:8:7]) #第二個數字要輸入總數
print ("[",a[0],a[7],"]") #輸入位置

#============================================================================================        
#例外處理=========================================================================================
#============================================================================================
#有做例外處理，程式才不會被強制中斷(閃退)
try:
    user = int(input('請輸入數字: ')) #如果輸入無法轉型的字，例如英文字母，會直接跳到except做例外處理
    print('hello')
    print(user+3)
except ValueError:
    print('轉型失敗，請輸入正確的數字')

#即使發生例外，依然會持續往下執行
# except Exception  可以捕捉所有例外，但會不知道是什麼例外導致中斷
#若要描述可用 except Exception as e:
# print('有例外:'str(e)
a = [1,2,3,4]
user = int(input('數字: '))
try:
    print(a[user])
#會產生多個例外，就寫多個except
except IndexError :
    print('資料不存在')

#============================================================================================        
#set=========================================================================================
#============================================================================================
a = {1,2,3,4}
#set特色:1沒有順序2.資料不重複
#set運算:1.交集2.差集3.聯集4.對稱差集
def p(msg):
    print(msg)
p(type(a)) #set沒有順序，下面顯示結果只是剛好照順序。因為沒有順序，所以無法藉由索引找到某一筆資料
p(a)
#可以透過for in取得set的每一筆資料，但無法只抓某一筆資料
employee1 = {'英文','日語','台語','粵語'}
employee2 = {'法語','德語','中文','日語','台語'}
print(f'只有員工1號會的語言:{employee1 -employee2 }') #差集，保留前者不與後者重複的內容
print(f'兩人都會的語言:{employee2 & employee1 }') #交集，兩者重複之內容
print(f'兩人總共會的語言:{employee1 | employee2 }') #聯集，兩者相加且扣除重複的
print(f'那些語言只有一個人會的:{employee1 ^ employee2 }') #對稱差集，扣掉兩個集合內都有的

#群集資料
#1==>list清單
#   加資料append，移除資料remove
#2==>set集合(1.資料不重複2.沒有順序)
#   無法取得裡面某一筆資料，因為沒有順序
#   加資料add，移除資料remove
#3==>dict字典
#4==>tuple元組

#============================================================================================        
#猜數字遊戲=========================================================================================
#============================================================================================
#while 無窮迴圈，藉由條件是否成立決定程式是否可以進行，請記得需要有能停止的條件
#可搭配break
import random
a = ['0','1','2','3','4','5','6','7','8','9']
answer = random.sample(a,4) #使用randint會出現重複
answer = answer[0] + answer[1] + answer[2] + answer[3]
print(f'答案: {answer}')
gc = 0 #紀錄猜測次數
while True:
    user = input('請猜0~9之間的四位數(不可以重複): ')
    gc +=1 #次數加1
    print(f'已經猜了{gc}次')
    try:
        int(user)
    except ValueError:
        print ('只能輸入數字，請重新輸入')
        continue
    if len(user) !=4:
        print('只能輸入四個數字，請重新輸入')
        continue
    if len(set(user)) != 4:
        print('數字不可重覆, 請重新輸入')
        continue
    if user == answer:
        print(f'猜對了，總共猜了{gc}次')
        break
    how_many_A = 0
    if answer[0] == user[0]:
        how_many_A+=1
    if answer[1] == user[1]:
        how_many_A+=1
    if answer[2] == user[2]:
        how_many_A+=1
    if answer[3] == user[3]:
        how_many_A+=1  

    how_many_B = 0
    if user[0] in answer and user[0] != answer[0]:
        how_many_B += 1
    if user[1] in answer and user[1] != answer[1]:
        how_many_B += 1
    if user[2] in answer and user[2] != answer[2]:
        how_many_B += 1
    if user[3] in answer and user[3] != answer[3]:
        how_many_B += 1
    print(f'{how_many_A}A{how_many_B}B')
